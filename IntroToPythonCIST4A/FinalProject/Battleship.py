# -*- coding: utf-8 -*-
"""PythonFinalProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rwize27xCpcRappi1hNN-gpzeCH9YW9W
"""

#Did use AI for some help

import random


class Game:
    #Checks after every turn to see if a player is defeated after all of their ships are destroyed
    def checkVictory(self, player, opponent):
        if player.shipsLeft <= 0: #No ships left
            print(f"\n{player.name} loses!")
            print(f"{opponent.name} is the winner!") # other player wins
            return False
        else:
            return True

class Player: #Parent class with basic attributes
    def __init__(self, name, myShips, myBoard, shipsLeft):
        self.name = name
        self.myShips = myShips
        self.myBoard = myBoard
        self.shipsLeft = shipsLeft #Ship counter; used later to check if zero, then player loses


    def translateCoordinate(self, verticalCoordinate): #Verical coordinates are letters (A-H)
        letterToCoordinate = {"A": 0, "B": 1, "C": 2, "D": 3, "E": 4, "F": 5, "G": 6, "H": 7} #Dictionary to convert letter to number
        verticalCoordinate = letterToCoordinate[verticalCoordinate] #Number can now be used as list index
        return verticalCoordinate
    def reverseTranslatee(self, verticalCoordinate): #Verical coordinates are letters (A-H)
        coordinateToLetter = {0:"A", 1:"B", 2:"C", 3:"D", 4:"E", 5:"F", 6:"G", 7:"H"} #Dictionary to convert letter to number
        verticalLetter = coordinateToLetter[verticalCoordinate] #Number can now be used as list index
        return verticalLetter


class User(Player): #Inherits from Player class and is the one that refers to the player controlled by the user
    def __init__(self, name, myShips, myBoard, shipsLeft):
        super().__init__(name, myShips, myBoard, shipsLeft)

    def generateUserBoard(self):
        while True: #Will ask user again and again until user and program agree
            self.myBoard.arrangeShips(player1) #Randomly arranges ships
            self.myBoard.displayBoard() #Displays the board for the user to see
            try:
                choice = input("Do you like this ship arrangement? (y/n)")
                choice = choice.lower()
                if choice != "y" and choice != "n": #Program will only accept 'y' or 'n' otherwise it is invalid
                    self.myBoard.resetBoard() #Resets board
                    raise ValueError("Invalid input")
                if choice == "n":
                    self.myBoard.resetBoard() #delete board arrangement and loop back
                if choice == "y":
                    break #Board arrangement set and exits loop
            except Exception as e:
                print(f"{e}")
                continue #loop back


    def hitOpponent(self, opponent): #Class function to hit opponent's ships
        while True:
            opponent.myBoard.displayHiddenBoard()
            #Displays a board that hides opponent's ships are, but can show whether a hit is successful
            print(f"{self.name}'s turn!")

            try:
                attempt = input("Choose a coordinate point (A-H,1-8): ") #Takes two comma seperated values
                coordinateY, coordinateX = attempt.split(',') #Splits the input into a y and an x coordinate
                coordinateY = self.translateCoordinate(coordinateY.strip().upper()) #Translates coordinate from letter tp number
                coordinateX = int(coordinateX)

                if opponent.myBoard.checkHit(coordinateY, coordinateX): # returns true if ship is hit, false if not
                    print("\nHit!")
                    opponent.myBoard.displayHiddenBoard()
                    for ship in opponent.myShips:
                        if ship.checkSelf(coordinateY, coordinateX,opponent): #Checks if ship is destroyed
                            opponent.shipsLeft -= 1
                            break
                else:
                    print("Miss!")
                    opponent.myBoard.displayHiddenBoard()
                    break

            #except (ValueError, KeyError, IndexError):
            except Exception as e:
                print("Invalid input. Try again!")
                print(f"error: {e}")
                continue


class ComputerOpponent(Player): #Inherits from Player class
    def __init__(self, name, myShips, myBoard, shipsLeft):
        super().__init__(name, myShips, myBoard, shipsLeft)

    def generateComputerBoard(self):
        self.myBoard.arrangeShips(self) #Randomly arranges ships

    def hitOpponentRandom(self, opponent):
        print(f"{self.name}'s turn!")
        coordinateY = random.randint(0, 7)
        coordinateX = random.randint(1, 8)
        #Picks random coordinate to hit
        letterY = self.reverseTranslatee(coordinateY)
        print(f"{letterY},{coordinateX}")
        if opponent.myBoard.checkHit(coordinateY, coordinateX):
            print("Hit!")
            for ship in opponent.myShips: #Checks if ship is destroyed
                if ship.checkSelf(coordinateY, coordinateX, opponent):
                    opponent.shipsLeft -= 1
                    break
            self.smartHit(opponent, coordinateY, coordinateX)
            opponent.myBoard.displayHiddenBoard()
        else:
            print("Miss!")
            opponent.myBoard.displayHiddenBoard()

    def smartHit(self, opponent, coordinateY, coordinateX): #Used to make a more educated guess if it has already hit part of a ship
        horizontalOrVertical = random.randint(0, 1)
        c = random.randint(-1, 1)
        #Randomly decides which direction from the previous successful hit to hit (up, down, left, or right)
        if horizontalOrVertical == 0: #checks so that it doesn't hit outside of board
            if coordinateX == 1:
                c = 1
            elif coordinateX == 8:
                c = -1
            newCoordinateX = coordinateX + c
            newCoordinateY = coordinateY

        else:                       #checks so that it doesn't hit outside of board
            if coordinateY == 0:
                c = 1
            elif coordinateY == 7:
                c = -1
            newCoordinateX = coordinateX
            newCoordinateY = coordinateY + c
        newLetterY = self.reverseTranslatee(newCoordinateY)
        print(f"{newLetterY},{newCoordinateX}")
        if opponent.myBoard.checkHit(newCoordinateY, newCoordinateX): #If another successful hit, calls on function to make another hit

            print("Hit!")
            opponent.myBoard.displayHiddenBoard()

            self.smartHit(opponent, newCoordinateY, newCoordinateX)
            for ship in opponent.myShips:
                if ship.checkSelf(newCoordinateY, newCoordinateX, opponent):
                    opponent.shipsLeft -= 1
                    break
        else:
            print("Miss!")
            opponent.myBoard.displayHiddenBoard()


class Ship: #Class for each individual ship
    def __init__(self, name, size):
        self.name = name
        self.size = size
        self.hits = 0
        #Lists that contain coordinates that are filled by the ship
        self.positionX = []
        self.positionY = []

    def generatePosition(self, playerBoard): #Randomly generates ship position
        direction = random.randint(1, 2) #Either vertical or horizontal
        if direction == 1: #Vertical-facing ship
            xValue = random.randint(1, 8 - self.size)
            yValue = random.randint(0, 7)
            if not playerBoard.checkXPosition(self.size, xValue, yValue): #Checks if ships will overlap
                self.generatePosition(playerBoard) #Tries to place ship again - recursive
            else:
                # Registers ship's coordinates
                yList, xList = playerBoard.placeShip(self.size, xValue, yValue, direction)
                self.positionX = xList
                self.positionY = yList
        else: #Horizontal-facing ship
            xValue = random.randint(1, 8)
            yValue = random.randint(0, 8 - self.size)
            if not playerBoard.checkYPosition(self.size, xValue, yValue): #Checks if ships will overlap
                self.generatePosition(playerBoard) #Tries to place ship again - recursive
            else:
                yList, xList = playerBoard.placeShip(self.size, xValue, yValue, direction)
                self.positionX = xList
                self.positionY = yList


    def checkSelf(self, yHit, xHit, opponent): #Checks if a hit landed on ship
        for i in range(len(self.positionX)):
            if self.positionX[i] == xHit and self.positionY[i] == yHit:
                self.hits += 1 #increases hits sustained by ship
                if self.hits == self.size: #means that all the squares filled by ship were destroyed - ship fully destroyed
                    print(f"{self.name} destroyed! ")
                    return True

                return False
        return False


class Board: #board class that registers coordinates of ships and hits
    def __init__(self, size, name):
        self.size = size
        self.name = name
        self.board = [
            ["A", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["B", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["C", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["D", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["E", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["F", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["G", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["H", "~", "~", "~", "~", "~", "~", "~", "~"],
        ]
        self.hiddenBoard = [
            ["A", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["B", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["C", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["D", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["E", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["F", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["G", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["H", "~", "~", "~", "~", "~", "~", "~", "~"],
        ]

    def arrangeShips(self, player): #Randomly arranges all ships
        for ship in player.myShips:
            ship.generatePosition(player.myBoard)

    def displayBoard(self): #Prints the whole board
        print(f"{self.name}: ")
        print("  1 2 3 4 5 6 7 8 ")
        for row in self.board:
            print(*row)

    def displayHiddenBoard(self): #Prints the board without ships
        print(f"{self.name}:")
        print("\n  1 2 3 4 5 6 7 8 ")
        for row in self.hiddenBoard:
            print(*row)




    def resetBoard(self): #Reset board back to original
        self.board = [
            ["A", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["B", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["C", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["D", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["E", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["F", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["G", "~", "~", "~", "~", "~", "~", "~", "~"],
            ["H", "~", "~", "~", "~", "~", "~", "~", "~"],
        ]

    def placeShip(self, shipSize, x, y, direction): #Prints locations on board with chips
        positionX = []
        positionY = []
        if direction == 1: #If ship is horizontal
            for i in range(shipSize):
                self.board[y][x + i] = "0" # '0' represents a square with a ship filling it
                positionX.append(x + i)
                positionY.append(y)
        else:
            for i in range(shipSize):
                self.board[y + i][x] = "0"
                positionX.append(x)
                positionY.append(y + i)

        return positionY, positionX

    def checkXPosition(self, shipSize, x, y): #checks first if a ship is already occupying square to avoid overlap of ships
        for i in range(shipSize):
            if self.board[y][x + i] == "0":
                return False
        return True

    def checkYPosition(self, shipSize, x, y): #checks first if a ship is already occupying square to avoid overlap of ships
        for i in range(shipSize):
            if self.board[y + i][x] == "0":
                return False
        return True

    def checkHit(self, coordinateY, coordinateX): #Fills square on board with propper symbol
        if self.board[coordinateY][coordinateX] == "~": #Prints 'x' if it doesn't hit ship
            self.board[coordinateY][coordinateX] = "X"
            self.hiddenBoard[coordinateY][coordinateX] = "X"
            return False
        elif self.board[coordinateY][coordinateX] == "0": #Prints 'H' if it hits a ship
            self.board[coordinateY][coordinateX] = "H"
            self.hiddenBoard[coordinateY][coordinateX] = "H"
            return True
        else:
            return False


game = Game()
# Player boards
userBoard = Board(8, "User's Board")

computerBoard = Board(8, "Computer's Board")

#Ships
carrier1 = Ship("Carrier",5)
battleship1 = Ship("Battleship", 4)
cruiser1 = Ship("Cruiser", 3)
submarine1 = Ship("Submarine", 3)
destroyer1 = Ship("Destroyer", 2)

carrier2 = Ship("Carrier",5)
battleship2 = Ship("Battleship", 4)
cruiser2 = Ship("Cruiser", 3)
submarine2 = Ship("Submarine", 3)
destroyer2 = Ship("Destroyer", 2)

#Players and their ships

player1Ships = [carrier1, battleship1, cruiser1, submarine1, destroyer1]
#player1Ships = [submarine1, destroyer1]

player1 = User("Player 1", player1Ships, userBoard, 5)

player2Ships = [carrier2, battleship2, cruiser2, submarine2, destroyer2]
#player2Ships = [submarine2, destroyer2]

player2 = ComputerOpponent("Player 2", player2Ships, computerBoard, 5)

#Randomize positions
player2.generateComputerBoard()
player1.generateUserBoard()

while True:
    #player2.myBoard.displayBoard() #Delete when full game prototype is to be tested
    player1.hitOpponent(player2) #Player 1's turn to attempt to hit opponent's ship
    print(f"{player2.shipsLeft} ships left\n")
    if not game.checkVictory(player2, player1): #Check if player has 0 ships; if yes, then game ends and opponent wins
        break
    player2.hitOpponentRandom(player1) #Player 1's turn to attempt to hit opponent's ship
    print(f"{player1.shipsLeft} ships left\n")
    if not game.checkVictory(player1, player2): #Check if player has 0 ships; if yes, then game ends and opponent wins
        break


